# PRD — CasaLeones POS v5.0: Ruta al 10/10

**Versión:** 1.1  
**Fecha:** 15 de febrero 2026  
**Autor:** Equipo de Ingeniería  
**Estado:** Sprint 6 completado ✅ — PRD completado  
**Baseline:** Auditoría v4.0 (7.6/10 global)  
**Objetivo:** 10/10 en los 6 rubros de evaluación  
**Progreso:** 32/32 iniciativas completadas (100%) — 173h ejecutadas de 173h  

---

## Índice

1. [Resumen Ejecutivo](#1-resumen-ejecutivo)
2. [Arquitectura y Escalabilidad (8→10)](#2-arquitectura-y-escalabilidad-810)
3. [Gestión Operativa (8.5→10)](#3-gestión-operativa-8510)
4. [Seguridad y Cumplimiento (8→10)](#4-seguridad-y-cumplimiento-810)
5. [UX/UI (7→10)](#5-uxui-710)
6. [Reporteo y Analytics (7.5→10)](#6-reporteo-y-analytics-7510)
7. [Cumplimiento Fiscal (6.5→10)](#7-cumplimiento-fiscal-6510)
8. [Plan de Ejecución](#8-plan-de-ejecución)
9. [Criterios de Aceptación Globales](#9-criterios-de-aceptación-globales)
10. [Riesgos y Mitigaciones](#10-riesgos-y-mitigaciones)

---

## 1. Resumen Ejecutivo

Este PRD define **32 iniciativas concretas** agrupadas en los 6 pilares de evaluación. Cada iniciativa incluye problema, solución, archivos afectados, criterios de aceptación y estimación. La ejecución completa lleva el sistema de **7.6/10 a 10/10**.

### Tabla de Brechas

| Pilar | Actual | Meta | Delta | # Iniciativas |
|-------|--------|------|-------|---------------|
| Arquitectura y Escalabilidad | 8 | 10 | +2 | 6 |
| Gestión Operativa | 8.5 | 10 | +1.5 | 6 |
| Seguridad y Cumplimiento | 8 | 10 | +2 | 7 |
| UX/UI | 7 | 10 | +3 | 5 |
| Reporteo y Analytics | 7.5 | 10 | +2.5 | 4 |
| Cumplimiento Fiscal | 6.5 | 10 | +3.5 | 4 |
| **Total** | **7.6** | **10** | **+2.4** | **32** |

---

## 2. Arquitectura y Escalabilidad (8→10)

### 2.1 — Redis como backend de sesiones, caché y rate limiting

**Problema:** Flask-Limiter usa `memory://` — los contadores se pierden al reiniciar. Las sesiones viven en cookies sin backend compartido. No hay capa de caché.

**Solución:**

1. Cambiar `storage_uri` de Limiter a `redis://redis:6379/0`
2. Configurar `Flask-Session` con backend Redis (`redis:6379/1`)
3. Implementar caché de queries frecuentes con `Flask-Caching` + Redis (`redis:6379/2`)
4. Cachear: catálogo de productos (5 min TTL), dashboard stats (30s TTL), lista de mesas (5 min TTL)

**Archivos afectados:**
- `backend/extensions.py` — agregar `Session`, `Cache`; cambiar `storage_uri`
- `backend/app.py` — inicializar extensiones
- `config.py` — agregar `SESSION_TYPE`, `CACHE_TYPE`, `CACHE_REDIS_URL`
- `backend/requirements.txt` — agregar `Flask-Session`, `Flask-Caching`
- `backend/routes/api.py`, `admin_routes.py` — decorar endpoints con `@cache.cached()`

**Criterios de aceptación:**
- [ ] Rate limiter persiste contadores entre reinicios del app container
- [ ] Sesiones sobreviven restart del contenedor web
- [ ] Segundo request a `/api/productos` dentro de 5 min se sirve de caché (<5ms)
- [ ] `docker-compose.yml` no requiere cambios (Redis ya existe)

**Estimación:** 3 horas

---

### 2.2 — Filtrado de datos por sucursal activa

**Problema:** Multi-sucursal tiene el modelo (`Sucursal`, FKs) pero las queries de órdenes, reportes, inventario y ventas **no filtran por `sucursal_id`**. Un admin ve datos de todas las sucursales mezclados.

**Solución:**

1. Crear middleware `@app.before_request` que inyecte `g.sucursal_id` desde `session['sucursal_id']`
2. Crear utility `filtrar_por_sucursal(query, modelo)` que añade `.filter(modelo.sucursal_id == g.sucursal_id)` si hay sucursal en sesión
3. Aplicar filtro en:
   - `meseros.py` — órdenes del mesero
   - `reportes.py` — todos los reportes
   - `admin_routes.py` — dashboard, corte de caja
   - `inventario.py` — ingredientes y movimientos
   - `reservaciones.py` — mesas y reservaciones
4. Superadmin puede ver "Todas" como opción de sucursal (sin filtro)
5. Asignar `sucursal_id` a `Orden` al crear desde mesero

**Archivos afectados:**
- `backend/app.py` — `before_request` hook
- `backend/utils.py` — función `filtrar_por_sucursal()`
- `backend/routes/meseros.py`, `reportes.py`, `admin_routes.py`, `inventario.py`, `reservaciones.py`
- `backend/models/models.py` — agregar `sucursal_id` FK a `Ingrediente`
- `migrations/versions/c005_*.py` — migración para FK

**Criterios de aceptación:**
- [ ] Mesero en Sucursal A solo ve órdenes de Sucursal A
- [ ] Reportes filtran por sucursal activa en sesión
- [ ] Superadmin con "Todas" ve datos consolidados
- [ ] Crear orden asigna `sucursal_id` automáticamente
- [ ] Corte de caja es por sucursal

**Estimación:** 8 horas

---

### 2.3 — Eliminar frontend React (deuda técnica)

**Problema:** Carpeta `frontend/` contiene un proyecto React que no se usa. Genera confusión, aumenta tamaño del repo, y crea ambigüedad sobre qué stack es el oficial.

**Solución:**

1. Eliminar carpeta `frontend/` completa
2. Eliminar `package.json` raíz si solo servía para scripts de React
3. Actualizar `CLAUDE.md` para reflejar "Frontend: Jinja2 (único)"
4. Agregar nota en `.gitignore` para no recrear

**Archivos afectados:**
- Eliminar: `frontend/` (todo el directorio)
- Editar: `CLAUDE.md`, `package.json` (raíz)

**Criterios de aceptación:**
- [ ] No existe carpeta `frontend/`
- [ ] `CLAUDE.md` dice "Frontend: Jinja2 Templates"
- [ ] `npm run start:frontend` eliminado o redirigido
- [ ] Docker build no incluye archivos React

**Estimación:** 1 hora

---

### 2.4 — Connection pooling y configuración de producción

**Problema:** SQLAlchemy usa el pool por defecto sin tunear. En producción con múltiples workers, puede agotar conexiones a Postgres.

**Solución:**

1. Configurar pool en `config.py`:
   ```python
   SQLALCHEMY_ENGINE_OPTIONS = {
       'pool_size': 10,
       'pool_recycle': 300,
       'pool_pre_ping': True,
       'max_overflow': 20,
   }
   ```
2. Crear `config.ProductionConfig` y `config.DevelopmentConfig`
3. Agregar `gunicorn` con workers configurables al `dockerfile`
4. Reemplazar `python3 -m backend.app` con `gunicorn` en docker-compose para producción

**Archivos afectados:**
- `config.py` — agregar clases de config, `SQLALCHEMY_ENGINE_OPTIONS`
- `dockerfile` — instalar gunicorn
- `docker-compose.yml` — cambiar command para producción
- `backend/requirements.txt` — agregar `gunicorn`

**Criterios de aceptación:**
- [ ] `pool_pre_ping: True` evita errores de conexión stale
- [ ] `ProductionConfig` vs `DevelopmentConfig` seleccionable via `FLASK_ENV`
- [ ] Gunicorn con `--workers 4 --worker-class eventlet` funciona
- [ ] Health check `/health` reporta DB pool stats

**Estimación:** 4 horas

---

### 2.5 — Test suite básica (pytest)

**Problema:** Cero tests automatizados. No hay forma de validar que cambios no rompan funcionalidad.

**Solución:**

1. Crear estructura: `tests/conftest.py`, `tests/test_auth.py`, `tests/test_orders.py`, `tests/test_pagos.py`, `tests/test_inventario.py`, `tests/test_reportes.py`
2. Fixtures: app de prueba con DB SQLite en memoria, usuario factory, orden factory
3. Cobertura mínima:
   - Auth: login/logout/roles
   - Órdenes: crear, agregar productos, enviar, estados
   - Pagos: multi-pago, split, cambio
   - Inventario: entrada, merma, descuento automático
   - Reportes: dashboard, CSV export
4. Comando: `pytest tests/ -v --cov=backend --cov-report=term-missing`

**Archivos nuevos:**
- `tests/__init__.py`
- `tests/conftest.py`
- `tests/test_auth.py`
- `tests/test_orders.py`
- `tests/test_pagos.py`
- `tests/test_inventario.py`
- `tests/test_reportes.py`
- `backend/requirements.txt` — agregar `pytest`, `pytest-cov`

**Criterios de aceptación:**
- [ ] `pytest` corre sin errores
- [ ] Cobertura ≥ 70% en `backend/routes/`
- [ ] Cada módulo crítico tiene ≥ 5 test cases
- [ ] Tests se pueden correr en CI (sin Docker)

**Estimación:** 12 horas

---

### 2.6 — Docker multi-stage build y optimización

**Problema:** Dockerfile actual copia todo sin optimizaciones. No hay `.dockerignore`. Build lento.

**Solución:**

1. Crear `.dockerignore` (excluir `__pycache__`, `.git`, `backups/`, `instance/`, `node_modules/`)
2. Multi-stage build: stage 1 instala deps, stage 2 copia app
3. Usar imagen slim: `python:3.12-slim`
4. Health check en Dockerfile

**Archivos afectados:**
- `dockerfile` — reescribir con multi-stage
- Nuevo: `.dockerignore`

**Criterios de aceptación:**
- [ ] Imagen final < 200MB
- [ ] Build time < 60 segundos (cached)
- [ ] `.dockerignore` excluye archivos innecesarios
- [ ] Health check integrado en container

**Estimación:** 2 horas

---

## 3. Gestión Operativa (8.5→10)

### 3.1 — Impresión ESC/POS para impresoras térmicas

**Problema:** Los tickets se imprimen via `window.print()` del navegador. En restaurantes profesionales se necesitan impresoras térmicas ESC/POS (Epson TM-T20, Star TSP100).

**Solución:**

1. Instalar `python-escpos` en requirements
2. Crear servicio `backend/services/printer.py`:
   - Configuración: `PRINTER_TYPE` (usb/network/none), `PRINTER_HOST`, `PRINTER_PORT`
   - Funciones: `imprimir_comanda(orden)`, `imprimir_ticket_cuenta(orden)`, `imprimir_corte_caja(corte)`
   - Template de ticket con logo, IVA desglosado, QR para factura
3. Endpoint `POST /meseros/ordenes/<id>/imprimir`:
   - Tipo: `comanda` (para cocina) o `cuenta` (para comensal)
4. Auto-imprimir comanda al enviar a cocina (configurable)
5. Fallback a `window.print()` si no hay impresora configurada

**Archivos afectados:**
- Nuevo: `backend/services/printer.py`
- `backend/routes/meseros.py` — endpoint imprimir
- `backend/routes/admin_routes.py` — imprimir corte de caja
- `config.py` — vars de impresora
- `backend/requirements.txt` — `python-escpos`
- `backend/static/js/meseros.js` — botón que llama endpoint

**Criterios de aceptación:**
- [ ] Impresora USB/red imprime ticket con formato correcto
- [ ] Comanda incluye: #orden, mesa, productos por estación, hora
- [ ] Ticket cuenta incluye: desglose, IVA, total, método de pago, cambio
- [ ] Sin impresora configurada, cae a browser print sin error
- [ ] Configurable via `.env` (PRINTER_TYPE=none|usb|network)

**Estimación:** 8 horas

---

### 3.2 — Validación de stock antes de aceptar orden

**Problema:** Se puede vender un producto aunque seus ingredientes tengan stock en 0. El descuento de inventario ocurre hasta el momento del pago.

**Solución:**

1. Crear función `verificar_stock_disponible(producto_id, cantidad)` en `backend/utils.py`:
   - Lee receta del producto
   - Para cada ingrediente verifica `stock_actual >= cantidad_por_unidad * cantidad`
   - Retorna `(bool, list[ingredientes_faltantes])`
2. Llamar en `meseros.py > agregar_productos_a_orden()` antes de agregar
3. Opción configurable: `INVENTARIO_VALIDAR_STOCK = True|False` (para restaurantes que aún no tienen inventario capturado)
4. Warning visual si stock está bajo pero no agotado
5. Bloqueo solo si stock es 0 o negativo

**Archivos afectados:**
- `backend/utils.py` — `verificar_stock_disponible()`
- `backend/routes/meseros.py` — validación pre-agregar
- `backend/routes/orders.py` — validación en API
- `config.py` — `INVENTARIO_VALIDAR_STOCK`
- `backend/static/js/meseros.js` — mostrar warning/error

**Criterios de aceptación:**
- [ ] Producto sin stock muestra error y no se agrega
- [ ] Producto con stock bajo muestra advertencia amarilla pero permite agregar
- [ ] `INVENTARIO_VALIDAR_STOCK=False` desactiva la validación
- [ ] Respuesta API incluye `ingredientes_faltantes` para troubleshooting

**Estimación:** 4 horas

---

### 3.3 — Flujo completo de mesa: apertura → cierre

**Problema:** El estado de la mesa no se actualiza automáticamente con el ciclo de vida de la orden. No hay visibilidad de mesas libres/ocupadas en tiempo real.

**Solución:**

1. Automatizar cambios de estado de mesa:
   - `disponible` → `ocupada` al crear orden en mesa
   - `ocupada` → `disponible` al pagar/cancelar orden (y no hay más órdenes activas)
   - `reservada` → `ocupada` al completar reservación
2. Emitir Socket.IO `mesa_estado_actualizado` en cada cambio
3. Crear widget de mapa de mesas en dashboard de meseros (no solo API)
4. Indicador visual: verde=disponible, rojo=ocupada, azul=reservada, gris=mantenimiento

**Archivos afectados:**
- `backend/routes/meseros.py` — auto-actualizar mesa en crear orden, pagar, cancelar
- `backend/routes/reservaciones.py` — ya maneja estados
- `backend/templates/meseros.html` — widget mapa de mesas
- `backend/static/js/meseros.js` — escuchar `mesa_estado_actualizado`, renderizar mapa
- `backend/static/css/styles.css` — estilos del mapa

**Criterios de aceptación:**
- [ ] Al crear orden en mesa, su estado cambia a `ocupada`
- [ ] Al pagar última orden de mesa, estado vuelve a `disponible`
- [ ] Mapa de mesas visible en dashboard de meseros con colores
- [ ] Actualización en tiempo real via Socket.IO
- [ ] Click en mesa disponible redirige a crear orden

**Estimación:** 6 horas

---

### 3.4 — Notas por item y modificaciones especiales

**Problema:** Las notas por item existen en el modelo pero no se muestran prominentemente en la pantalla de cocina ni hay UI dedicada para capturarlas.

**Solución:**

1. Al agregar producto, mostrar campo de notas opcional (modal rápido o inline)
2. En pantalla de cocina, mostrar notas en **negrita/color** debajo del producto
3. Notas comunes predefinidas (configurable): "Sin cebolla", "Extra picante", "Sin queso", "Término medio", etc.
4. Botones rápidos de notas frecuentes + campo libre

**Archivos afectados:**
- `backend/templates/detalle_orden.html` — UI notas al agregar
- `backend/templates/cocina/_ordenes_agrupadas_cards.html` — mostrar notas
- `backend/static/js/meseros.js` — modal/input de notas
- Nuevo: `backend/static/js/notas_rapidas.json` — config de notas predefinidas

**Criterios de aceptación:**
- [ ] Al agregar producto aparece campo de notas con sugerencias
- [ ] Notas visibles en pantalla de cocina con formato destacado
- [ ] Notas se guardan en `OrdenDetalle.notas`
- [ ] Notas comunes se seleccionan con un click

**Estimación:** 4 horas

---

### 3.5 — Historial de actividad y auditoría

**Problema:** No hay registro de quién hizo qué y cuándo. Cambios de estado, cancelaciones, descuentos tienen logging pero no una tabla consultable.

**Solución:**

1. Crear modelo `AuditLog`:
   ```python
   class AuditLog(db.Model):
       id, usuario_id, accion, entidad, entidad_id,
       datos_antes, datos_despues, ip, timestamp
   ```
2. Helper `registrar_auditoria(accion, entidad, entidad_id, antes, despues)`
3. Registrar eventos:
   - Crear/cancelar orden
   - Aplicar descuento
   - Pagar orden
   - Modificar producto/precio
   - Login/logout
   - Cambios de inventario (merma, ajuste)
   - Cancelar factura
4. Vista admin `/admin/auditoria` con filtros (usuario, acción, fecha, entidad)

**Archivos afectados:**
- `backend/models/models.py` — modelo `AuditLog`
- Nuevo: `backend/services/audit.py` — helper
- `backend/routes/meseros.py`, `admin_routes.py`, `auth.py`, `inventario.py`, `facturacion.py` — llamadas a auditoría
- Nuevo: `backend/routes/auditoria.py` — blueprint de vista
- Nuevo: `backend/templates/admin/auditoria/lista.html`
- `migrations/versions/c005_*.py` — migración

**Criterios de aceptación:**
- [ ] Cada acción crítica genera registro de auditoría
- [ ] Vista admin muestra historial con filtros
- [ ] Incluye IP y timestamp
- [ ] Datos antes/después en JSON para trazabilidad
- [ ] No impacta latencia (< 5ms overhead por registro)

**Estimación:** 8 horas

---

### 3.6 — Gestión de propinas

**Problema:** El campo `propina` existe en el modelo `Orden` pero no tiene UI ni flujo para capturarla.

**Solución:**

1. En modal de cobro, agregar campo de propina (monto fijo o % sugerido: 10%, 15%, 20%)
2. Propina se registra **separada** del total (no afecta IVA)
3. Visibilidad en:
   - Ticket impreso
   - Corte de caja (propinas del día)
   - Reporte por mesero (propinas recibidas)
4. Propina asignada al mesero de la orden

**Archivos afectados:**
- `backend/routes/meseros.py` — capturar propina en pago
- `backend/static/js/meseros.js` — UI propina en modal
- `backend/routes/admin_routes.py` — propinas en corte de caja
- `backend/routes/reportes.py` — propinas por mesero
- `backend/templates/admin/corte_caja.html` — totales de propina

**Criterios de aceptación:**
- [ ] Botones rápidos de % de propina en modal de cobro
- [ ] Propina no afecta cálculo de IVA
- [ ] Corte de caja muestra total de propinas del día
- [ ] Reporte de meseros incluye propinas acumuladas
- [ ] Ticket impreso muestra propina si aplica

**Estimación:** 4 horas

---

## 4. Seguridad y Cumplimiento (8→10)

### 4.1 — Content Security Policy (CSP)

**Problema:** No hay header `Content-Security-Policy`. Vulnerable a XSS por inyección de scripts externos.

**Solución:**

1. Agregar CSP en `set_security_headers()`:
   ```python
   response.headers['Content-Security-Policy'] = (
       "default-src 'self'; "
       "script-src 'self' 'unsafe-inline' cdn.jsdelivr.net cdnjs.cloudflare.com; "
       "style-src 'self' 'unsafe-inline' cdn.jsdelivr.net; "
       "img-src 'self' data:; "
       "connect-src 'self' ws: wss:; "
       "font-src 'self' cdn.jsdelivr.net; "
       "frame-ancestors 'none'; "
       "base-uri 'self'; "
       "form-action 'self';"
   )
   ```
2. Usar nonces para inline scripts (generar por request con `secrets.token_hex(16)`)
3. Pasar nonce a templates: `{{ csp_nonce }}`
4. Report-Only primero para detectar violations antes de enforce

**Archivos afectados:**
- `backend/app.py` — `set_security_headers()`, `before_request` para nonce
- `backend/templates/base.html` — `nonce="{{ csp_nonce }}"` en scripts inline
- Todas las templates con `<script>` inline

**Criterios de aceptación:**
- [ ] Header CSP presente en todas las responses
- [ ] Scripts inline usan nonce
- [ ] No hay violations en consola del navegador
- [ ] Socket.IO funciona bajo CSP (ws:/wss: permitido)
- [ ] CDN de Bootstrap permitido

**Estimación:** 5 horas

---

### 4.2 — Validación de webhooks de delivery

**Problema:** Los endpoints `/delivery/webhook/<plataforma>` aceptan cualquier request sin verificar autenticidad. Un atacante podría inyectar órdenes falsas.

**Solución:**

1. Implementar verificación de signature por plataforma:
   - **Uber Eats:** HMAC-SHA256 con `X-Uber-Signature` header
   - **Rappi:** API key en header `X-Rappi-API-Key`
   - **DiDi Food:** HMAC en header `X-DiDi-Signature`
2. Crear decorator `@verificar_webhook_signature`
3. Rechazar con 401 si la firma no coincide
4. Log de intentos rechazados con IP para monitoreo
5. Variables de entorno por plataforma: `UBER_EATS_WEBHOOK_SECRET`, `RAPPI_WEBHOOK_KEY`, `DIDI_WEBHOOK_SECRET`

**Archivos afectados:**
- Nuevo: `backend/services/webhook_auth.py` — verificación por plataforma
- `backend/routes/delivery.py` — aplicar decorator
- `config.py` — variables de webhook secrets

**Criterios de aceptación:**
- [ ] Request sin firma válida retorna 401
- [ ] Request con firma válida se procesa normalmente
- [ ] Cada plataforma tiene su método de verificación
- [ ] Intentos rechazados se loggean con IP
- [ ] Sin secret configurado, endpoint está deshabilitado (no abierto)

**Estimación:** 4 horas

---

### 4.3 — CORS restrictivo

**Problema:** CORS permite `"*"` en `/api/*`. Cualquier dominio puede hacer requests.

**Solución:**

1. Cambiar config de CORS:
   ```python
   CORS_ORIGINS = os.getenv('CORS_ORIGINS', 'http://localhost:5005').split(',')
   cors.init_app(app, resources={r"/api/*": {"origins": CORS_ORIGINS}})
   ```
2. En producción: solo el dominio real del restaurante
3. En desarrollo: `localhost:5005`
4. Agregar `supports_credentials=True` si se usan cookies

**Archivos afectados:**
- `config.py` — `CORS_ORIGINS`
- `backend/app.py` — pasar orígenes dinámicos

**Criterios de aceptación:**
- [ ] Requests desde dominios no autorizados son rechazados con CORS error
- [ ] `localhost` funciona en desarrollo
- [ ] Configurable via variable de entorno
- [ ] Socket.IO también respeta orígenes (ya no `cors_allowed_origins="*"`)

**Estimación:** 1 hora

---

### 4.4 — Política de contraseñas

**Problema:** No hay validación de fuerza de contraseñas. Un admin puede crear usuarios con password "123".

**Solución:**

1. Crear `backend/services/password_policy.py`:
   - Mínimo 8 caracteres
   - Al menos 1 mayúscula, 1 minúscula, 1 número
   - No igual al email o nombre
   - No en lista de passwords comunes (top 1000)
2. Aplicar en:
   - Crear usuario (`admin_routes.py`)
   - Cambiar contraseña (nuevo endpoint)
3. Endpoint `POST /admin/usuarios/<id>/cambiar_password`
4. Forzar cambio de password en primer login (campo `debe_cambiar_password` en `Usuario`)

**Archivos afectados:**
- Nuevo: `backend/services/password_policy.py`
- `backend/routes/admin_routes.py` — validación al crear/editar
- `backend/models/models.py` — campo `debe_cambiar_password`
- `backend/routes/auth.py` — forzar cambio si `debe_cambiar_password=True`
- Nuevo: `backend/templates/auth/cambiar_password.html`
- `migrations/versions/c005_*.py` — migración

**Criterios de aceptación:**
- [ ] Password "123" es rechazado con mensaje descriptivo
- [ ] Password "MiClav3Segura!" es aceptado
- [ ] Usuario nuevo forzado a cambiar password en primer login
- [ ] Admin puede forzar reset de password de cualquier usuario
- [ ] Feedback de validación en tiempo real en formulario

**Estimación:** 4 horas

---

### 4.5 — Protección contra enumeración de usuarios

**Problema:** El login responde de forma diferente si el email existe o no, permitiendo enumerar cuentas.

**Solución:**

1. Mensaje genérico siempre: "Credenciales inválidas"
2. Tiempo de respuesta constante (evitar timing attacks):
   ```python
   # Siempre ejecutar check_password aunque usuario no exista
   dummy_hash = generate_password_hash("dummy")
   if not usuario:
       check_password_hash(dummy_hash, password)  # constant time
   ```
3. Rate limit ya está (10/min) — mantener

**Archivos afectados:**
- `backend/routes/auth.py` — respuesta uniforme + timing

**Criterios de aceptación:**
- [ ] Mismo mensaje y tiempo de respuesta para email existente o inexistente
- [ ] No se revela si un email está registrado
- [ ] Timing difference < 50ms entre ambos casos

**Estimación:** 1 hora

---

### 4.6 — Protección de IDs secuenciales (IDOR)

**Problema:** Endpoints como `/ordenes/<id>/cobrar_info` usan IDs secuenciales. Un mesero podría acceder a órdenes de otro mesero cambiando el ID.

**Solución:**

1. Validar ownership en endpoints de mesero:
   - `detalle_orden` — solo si `orden.mesero_id == current_user.id` o es admin
   - `cobrar_info` — misma validación
   - `agregar_productos` — misma validación
2. Crear decorator `@verificar_propiedad_orden`
3. Admin/superadmin bypass (pueden ver todo)
4. Retornar 403 si no es propietario

**Archivos afectados:**
- `backend/routes/meseros.py` — decorator en endpoints de orden
- `backend/utils.py` — `verificar_propiedad_orden()`

**Criterios de aceptación:**
- [ ] Mesero A no puede ver/modificar órdenes de Mesero B
- [ ] Admin puede ver todas las órdenes
- [ ] Intentos de IDOR loggeados como warning
- [ ] Retorna 403, no 404 (para no revelar existencia)

**Estimación:** 3 horas

---

### 4.7 — Sanitización de inputs

**Problema:** Los campos de texto (notas, motivo descuento, nombre cliente) no se sanitizan. Potencial XSS almacenado.

**Solución:**

1. Crear `backend/services/sanitizer.py`:
   - `sanitizar_texto(text)` — strip HTML tags, trim whitespace
   - `sanitizar_rfc(rfc)` — validar formato, uppercase
   - `sanitizar_email(email)` — validar formato
   - `sanitizar_telefono(tel)` — solo números y +
2. Aplicar en todos los endpoints que reciben texto libre
3. Jinja2 ya escapa por defecto (`{{ var }}`) — verificar que no se use `{{ var|safe }}` sin necesidad
4. Agregar `bleach` para sanitización HTML donde se necesite texto rico

**Archivos afectados:**
- Nuevo: `backend/services/sanitizer.py`
- `backend/routes/clientes.py`, `reservaciones.py`, `meseros.py`, `inventario.py`
- `backend/requirements.txt` — `bleach`

**Criterios de aceptación:**
- [ ] `<script>alert('xss')</script>` en notas se guarda como texto plano
- [ ] RFC se guarda en mayúsculas, máximo 13 caracteres
- [ ] No hay `|safe` en templates sin justificación
- [ ] Email y teléfono validados en formato

**Estimación:** 3 horas

---

## 5. UX/UI (7→10)

### 5.1 — Mapa visual interactivo de mesas

**Problema:** Existe API JSON para mesas pero no hay interfaz visual. El mesero ve una lista plana, no un mapa del restaurante.

**Solución:**

1. Crear vista de mapa en `/meseros/mapa`:
   - Canvas/SVG interactivo con mesas drag-and-drop (admin config)
   - Mesas como cuadros con número, capacidad, estado (color)
   - Click: ver orden activa o crear nueva
   - Zoom para tablets
2. Admin puede configurar posición (`pos_x`, `pos_y`) y zona de cada mesa
3. Real-time updates via Socket.IO
4. Responsive: lista en móvil, mapa en tablet/desktop

**Archivos afectados:**
- Nuevo: `backend/templates/meseros/mapa_mesas.html`
- Nuevo: `backend/static/js/mapa_mesas.js`
- Nuevo: `backend/static/css/mapa_mesas.css`
- `backend/routes/meseros.py` — endpoint `/mapa`
- `backend/routes/reservaciones.py` — ya tiene API de mesas

**Criterios de aceptación:**
- [ ] Mapa visual con mesas coloreadas por estado
- [ ] Click en mesa disponible → crear orden
- [ ] Click en mesa ocupada → ver orden activa
- [ ] Actualización en tiempo real (sin refresh)
- [ ] Admin puede reposicionar mesas via drag-and-drop
- [ ] Responsive: lista en < 768px, mapa en >= 768px

**Estimación:** 10 horas

---

### 5.2 — Optimización para tablets

**Problema:** La UI funciona en tablet pero no está optimizada. Botones pequeños, scroll excesivo en pantalla de productos.

**Solución:**

1. CSS dedicado para tablets (768-1024px):
   - Botones mínimo 48x48px (touch targets)
   - Grid de productos 3 columnas (no 4)
   - Font sizes aumentados en cocina
   - Sticky header en detalle de orden
2. Swipe gestures (Hammer.js):
   - Swipe left en orden → cancelar
   - Swipe right en producto listo → marcar entregado
3. Landscape mode para cocina
4. Full-screen mode automático en PWA
5. Touch feedback visual (ripple effect)

**Archivos afectados:**
- `backend/static/css/styles.css` — media queries tablet
- Nuevo: `backend/static/css/tablet.css`
- `backend/templates/base.html` — incluir tablet.css
- `backend/templates/detalle_orden.html` — grid responsive
- `backend/templates/taqueros.html`, `comal.html`, `bebidas.html` — font sizes
- `backend/static/js/meseros.js` — touch gestures

**Criterios de aceptación:**
- [ ] Touch targets ≥ 48x48px en toda la app
- [ ] Grid de productos se adapta a orientación tablet
- [ ] Cocina legible a 1.5 metros de distancia
- [ ] No hay scroll horizontal en ningún viewport
- [ ] PWA abre en full-screen sin barra de navegador

**Estimación:** 8 horas

---

### 5.3 — Feedback visual y microinteracciones

**Problema:** Agregar producto no da feedback claro. Acciones críticas (pagar, cancelar) necesitan mejor confirmación.

**Solución:**

1. Toast notifications mejoradas:
   - Producto agregado: toast verde con nombre y cantidad
   - Error: toast rojo con detalle
   - Warning (stock bajo): toast amarillo
   - Pago exitoso: toast verde con confetti
2. Animaciones:
   - Producto agregado: card hace "bounce" o "pulse"
   - Badge del carrito incrementa con animación
   - Orden pagada: check mark animado
3. Confirmaciones:
   - Cancelar orden: modal de confirmación con motivo
   - Descuento > 50%: doble confirmación
4. Skeleton loading en lugar de spinners
5. Sonidos opcionales (configurable): notification bell para item listo

**Archivos afectados:**
- `backend/static/js/meseros.js` — toasts, animaciones
- `backend/static/css/styles.css` — animaciones CSS
- `backend/templates/detalle_orden.html` — feedback al agregar
- `backend/templates/meseros.html` — confirmación cancelar
- Nuevo: `backend/static/js/notifications.js` — sistema de notificaciones

**Criterios de aceptación:**
- [ ] Cada acción del usuario tiene feedback visual en < 200ms
- [ ] Toasts auto-dismiss en 3 segundos
- [ ] Cancelar orden requiere confirmación con motivo
- [ ] Skeleton loading en carga de datos
- [ ] Sonidos opcionales (toggle en settings)

**Estimación:** 6 horas

---

### 5.4 — Dashboard admin mejorado

**Problema:** Dashboard admin muestra KPIs básicos (ventas hoy, órdenes, ticket promedio). Falta visibilidad operativa.

**Solución:**

1. Widgets adicionales:
   - **Mesas activas** (ocupadas/total) con mini-mapa
   - **Órdenes en cocina** con timer promedio
   - **Alertas de stock** (ingredientes bajo mínimo)
   - **Propinas del día**
   - **Último corte de caja** con diferencia
2. Gráfica de ventas de los últimos 7 días (inline con Chart.js)
3. Actividad en vivo (últimas 5 acciones via Socket.IO)
4. Quick actions: crear usuario, registrar entrada inventario, ver reportes

**Archivos afectados:**
- `backend/templates/admin/dashboard.html` — widgets
- `backend/static/js/admin-dashboard.js` — fetch APIs, Chart.js
- `backend/routes/admin_routes.py` — APIs adicionales

**Criterios de aceptación:**
- [ ] Dashboard muestra 8+ KPIs relevantes
- [ ] Gráfica de ventas últimos 7 días
- [ ] Alertas de stock visibles sin navegar a inventario
- [ ] Actualización automática cada 30 segundos
- [ ] Tiempo de carga total < 2 segundos

**Estimación:** 6 horas

---

### 5.5 — Modo oscuro y accesibilidad (WCAG 2.1 AA)

**Problema:** No hay modo oscuro (útil para cocina con poca luz). Accesibilidad no auditada.

**Solución:**

1. **Modo oscuro:**
   - CSS variables para colores
   - Toggle en navbar (persistido en localStorage)
   - `prefers-color-scheme` para auto-detect
   - Cocina usa modo oscuro por defecto
2. **Accesibilidad WCAG 2.1 AA:**
   - Contraste mínimo 4.5:1 en todo el texto
   - `aria-label` en botones de icono
   - Focus visible en todos los controles
   - Skip-to-content link
   - `role="alert"` en toasts
   - Keyboard navigation en mapa de mesas
   - `lang="es"` ya está en `<html>`

**Archivos afectados:**
- `backend/static/css/styles.css` — CSS variables, dark mode
- Nuevo: `backend/static/css/dark-mode.css`
- `backend/templates/base.html` — toggle, skip-to-content
- Todas las templates — aria labels
- `backend/static/js/meseros.js` — keyboard handlers

**Criterios de aceptación:**
- [ ] Toggle de modo oscuro persiste entre sesiones
- [ ] Contraste ratio ≥ 4.5:1 (verificar con axe DevTools)
- [ ] Todos los botones icono tienen `aria-label`
- [ ] Tab navigation funciona en todos los flujos críticos
- [ ] 0 violations críticas en Lighthouse Accessibility

**Estimación:** 8 horas

---

## 6. Reporteo y Analytics (7.5→10)

### 6.1 — Gráficas interactivas con Chart.js

**Problema:** Reportes son tablas de datos. No hay visualización gráfica para facilitar toma de decisiones.

**Solución:**

1. Integrar Chart.js 4.x via CDN
2. Gráficas en reportes:
   - **Ventas:** Line chart por día, bar chart por hora del día
   - **Productos:** Horizontal bar chart de top 20, pie chart de categorías
   - **Meseros:** Bar chart comparativo
   - **Métodos de pago:** Doughnut chart
   - **Inventario:** Area chart de stock a lo largo del tiempo
   - **Mermas:** Bar chart por ingrediente
3. Tooltips con valores detallados
4. Responsive y exportable (canvas → PNG)
5. Toggle tabla/gráfica

**Archivos afectados:**
- `backend/templates/base.html` — CDN Chart.js (solo en reportes)
- `backend/templates/admin/reportes/ventas.html` — charts
- `backend/templates/admin/reportes/productos.html` — charts
- `backend/templates/admin/reportes/meseros.html` — charts
- `backend/templates/admin/reportes/pagos.html` — charts
- `backend/templates/admin/reportes/inventario.html` — charts
- Nuevo: `backend/static/js/reportes-charts.js` — helpers de chart
- `backend/routes/reportes.py` — endpoints JSON para datos de charts

**Criterios de aceptación:**
- [ ] Cada reporte tiene al menos 1 gráfica
- [ ] Gráficas son responsive
- [ ] Tooltip muestra valores exactos
- [ ] Se puede alternar entre vista tabla y gráfica
- [ ] Exportar gráfica como PNG

**Estimación:** 8 horas

---

### 6.2 — Reporte de rentabilidad por producto

**Problema:** Se sabe cuánto se vende pero no cuánto cuesta producir. Sin análisis de margen.

**Solución:**

1. Calcular costo por producto usando receta estándar:
   - `costo_producto = sum(receta.cantidad_por_unidad * ingrediente.costo_unitario)`
2. Reporte: tabla con columnas:
   - Producto, Precio venta, Costo producción, Margen ($), Margen (%), Cantidad vendida, Utilidad total
3. Ordenar por: margen %, utilidad total, cantidad vendida
4. Alertas: productos con margen < 30% en rojo
5. Gráfica: scatter plot precio vs margen
6. Export CSV

**Archivos afectados:**
- `backend/routes/reportes.py` — nuevo endpoint `/reportes/rentabilidad`
- Nuevo: `backend/templates/admin/reportes/rentabilidad.html`
- `backend/templates/admin/reportes/dashboard.html` — link
- `backend/templates/base.html` — link en nav (si aplica)

**Criterios de aceptación:**
- [ ] Cada producto con receta muestra su costo y margen
- [ ] Productos sin receta muestran "N/A" en costo
- [ ] Alerta visual en productos con margen < 30%
- [ ] Export CSV con todas las columnas
- [ ] Rango de fechas funciona como en otros reportes

**Estimación:** 5 horas

---

### 6.3 — Reporte de delivery y canal de venta

**Problema:** No hay visibilidad de ventas por canal (local vs delivery) ni comisiones pagadas.

**Solución:**

1. Reporte con desglose:
   - Ventas por canal (local, uber_eats, rappi, didi_food)
   - Total ventas, comisiones, ventas netas por plataforma
   - Ticket promedio por canal
   - Volumen por hora del día y canal
2. Gráfica: stacked bar chart por canal
3. KPI: % de ventas delivery vs local
4. Rango de fechas

**Archivos afectados:**
- `backend/routes/reportes.py` — endpoint `/reportes/delivery`
- Nuevo: `backend/templates/admin/reportes/delivery.html`
- `backend/templates/admin/reportes/dashboard.html` — link

**Criterios de aceptación:**
- [ ] Desglose por plataforma de delivery
- [ ] Comisiones sumadas por plataforma
- [ ] Gráfica de ventas por canal
- [ ] Rango de fechas funcional
- [ ] Se integra con dashboard de reportes

**Estimación:** 4 horas

---

### 6.4 — Export PDF de reportes y tickets

**Problema:** Solo hay export CSV. No hay PDF para compartir con contadores o dueños.

**Solución:**

1. Integrar `WeasyPrint` para generación de PDF server-side
2. Botón "Exportar PDF" en cada reporte
3. Template HTML dedicado para PDF (sin navbar, con logo, formato A4)
4. PDFs generados:
   - Reporte de ventas
   - Reporte de productos
   - Corte de caja
   - Reporte de rentabilidad
   - Factura (como respaldo si PAC no tiene PDF)
5. Nombre de archivo: `{tipo}_{fecha_inicio}_{fecha_fin}.pdf`

**Archivos afectados:**
- `backend/requirements.txt` — `WeasyPrint`
- Nuevo: `backend/services/pdf_generator.py`
- Nuevo: `backend/templates/pdf/reporte_ventas.html`
- Nuevo: `backend/templates/pdf/reporte_productos.html`
- Nuevo: `backend/templates/pdf/corte_caja.html`
- `backend/routes/reportes.py` — endpoints `/ventas/pdf`, `/productos/pdf`
- `backend/routes/admin_routes.py` — `/corte-caja/pdf`

**Criterios de aceptación:**
- [ ] PDF se genera en < 3 segundos
- [ ] Formato profesional con logo, fechas, totales
- [ ] Orientación portrait para reportes, landscape para tablas anchas
- [ ] Filename descriptivo
- [ ] Funciona en Docker (WeasyPrint deps instaladas)

**Estimación:** 8 horas

---

## 7. Cumplimiento Fiscal (6.5→10)

### 7.1 — Facturación CFDI funcional con Facturapi

**Problema:** La integración es scaffolding. Sin `FACTURAPI_KEY`, todo queda en "pendiente". Falta testing e2e con sandbox de Facturapi.

**Solución:**

1. Registrar cuenta sandbox en Facturapi (gratis)
2. Configurar `FACTURAPI_KEY` de sandbox en `.env.example`
3. Completar flujo:
   - Crear factura → timbrar → descargar XML/PDF
   - Cancelar factura → motivo SAT
   - Re-enviar factura por email
4. Validaciones:
   - RFC válido (regex + dígito verificador)
   - Uso CFDI válido para régimen fiscal
   - Total de factura = total de orden
5. UI de facturación mejorada:
   - Buscar cliente por RFC (autocompletado)
   - Preview antes de timbrar
   - Descargar XML/PDF desde lista

**Archivos afectados:**
- `backend/services/cfdi.py` — completar, manejar errores SAT específicos
- `backend/routes/facturacion.py` — download XML/PDF, re-enviar
- `backend/templates/admin/facturacion/crear.html` — preview, validación
- `backend/templates/admin/facturacion/lista.html` — botones download
- `.env.example` — agregar keys de ejemplo

**Criterios de aceptación:**
- [ ] Timbrado exitoso con Facturapi sandbox
- [ ] XML y PDF descargables
- [ ] Cancelación con motivo SAT funcional
- [ ] RFC validado antes de timbrar
- [ ] Errores del PAC mostrados con detalle legible

**Estimación:** 8 horas

---

### 7.2 — Notas de crédito (CFDI de egreso)

**Problema:** Si se necesita hacer una devolución o ajuste de una factura, no hay mecanismo.

**Solución:**

1. Modelo `NotaCredito`:
   ```python
   class NotaCredito(db.Model):
       id, factura_origen_id, uuid_cfdi, motivo, monto,
       estado, xml_url, pdf_url, fecha_creacion
   ```
2. Flujo:
   - Seleccionar factura origen → crear nota de crédito parcial o total
   - Timbrar via Facturapi (tipo: "E" egreso)
   - Relacionar con CFDI origen
3. UI en `/admin/facturacion/<id>/nota-credito`
4. Visible en lista de facturas como sub-item

**Archivos afectados:**
- `backend/models/models.py` — modelo `NotaCredito`
- `backend/services/cfdi.py` — función `crear_nota_credito()`
- `backend/routes/facturacion.py` — endpoints
- Nuevo: `backend/templates/admin/facturacion/nota_credito.html`
- `migrations/versions/c005_*.py` — migración

**Criterios de aceptación:**
- [ ] Nota de crédito se timbra correctamente
- [ ] Relacionada con CFDI origen
- [ ] Parcial y total soportadas
- [ ] XML/PDF descargables
- [ ] Visible en historial de facturación

**Estimación:** 6 horas

---

### 7.3 — Complemento de pago (CFDI "P")

**Problema:** Si un cliente paga después de la facturación (crédito), se requiere un complemento de pago ante el SAT.

**Solución:**

1. Agregar tipo de pago "crédito" / "pago posterior"
2. Factura emitida como PPD (Pago en Parcialidades o Diferido) con método "99"
3. Al recibir el pago:
   - Generar complemento de pago tipo "P"
   - Relacionar con factura original
   - Registrar método de pago real
4. Modelo: campo `metodo_pago_cfdi` en `Factura`

**Archivos afectados:**
- `backend/services/cfdi.py` — `crear_complemento_pago()`
- `backend/routes/facturacion.py` — endpoint complemento
- `backend/models/models.py` — campos adicionales en `Factura`
- Nuevo: `backend/templates/admin/facturacion/complemento_pago.html`

**Criterios de aceptación:**
- [ ] Factura PPD se emite con método "99"
- [ ] Complemento de pago se timbra al recibir dinero
- [ ] Relación UUID entre factura y complemento
- [ ] Soporta pagos parciales (múltiples complementos)

**Estimación:** 6 horas

---

### 7.4 — Validación de RFC y régimen fiscal

**Problema:** El RFC del cliente no se valida. Se puede ingresar cualquier texto como RFC.

**Solución:**

1. Validación de RFC persona física (13 chars) y moral (12 chars):
   - Regex: `^[A-ZÑ&]{3,4}\d{6}[A-Z\d]{3}$`
   - Dígito verificador (algoritmo SAT módulo 11)
   - RFC genérico público: `XAXX010101000`
   - RFC genérico extranjero: `XEXX010101000`
2. Catálogo de regímenes fiscales SAT actualizado
3. Catálogo de usos CFDI válidos por régimen
4. Validación en cliente (JS) y servidor (Python)
5. Auto-formateo: uppercase, trimmed

**Archivos afectados:**
- Nuevo: `backend/services/rfc_validator.py` — validaciones
- Nuevo: `backend/static/js/rfc-validator.js` — validación client-side
- `backend/routes/clientes.py` — validar al crear/editar
- `backend/routes/facturacion.py` — validar antes de timbrar
- Nuevo: `backend/data/catalogos_sat.json` — regímenes, usos CFDI

**Criterios de aceptación:**
- [ ] RFC inválido rechazado con mensaje descriptivo
- [ ] Dígito verificador validado
- [ ] RFC genérico aceptado para público en general
- [ ] Catálogo de regímenes actualizado (2024+)
- [ ] Validación en frontend antes de enviar form
- [ ] Usos CFDI filtrados por régimen seleccionado

**Estimación:** 5 horas

---

## 8. Plan de Ejecución

### Sprint 1 (Semanas 1-2): Seguridad + Base — ✅ COMPLETADO

| ID | Iniciativa | Estimación | Prioridad | Estado |
|----|-----------|------------|-----------|--------|
| 4.1 | Content Security Policy | 5h | P0 | ✅ |
| 4.2 | Validación webhooks delivery | 4h | P0 | ✅ |
| 4.3 | CORS restrictivo | 1h | P0 | ✅ |
| 4.4 | Política de contraseñas | 4h | P0 | ✅ |
| 4.5 | Anti-enumeración login | 1h | P0 | ✅ |
| 4.6 | Protección IDOR | 3h | P0 | ✅ |
| 4.7 | Sanitización inputs | 3h | P0 | ✅ |
| 2.1 | Redis como backend | 3h | P0 | ✅ |
| **Total Sprint 1** | | **24h** | | **8/8** |

### Sprint 2 (Semanas 3-4): Arquitectura + Operación — ✅ COMPLETADO

| ID | Iniciativa | Estimación | Prioridad | Estado |
|----|-----------|------------|-----------|--------|
| 2.2 | Filtrado por sucursal | 8h | P0 | ✅ |
| 2.3 | Eliminar frontend React | 1h | P1 | ✅ |
| 2.4 | Connection pooling + gunicorn | 4h | P1 | ✅ |
| 2.6 | Docker multi-stage | 2h | P1 | ✅ |
| 3.2 | Validación de stock | 4h | P0 | ✅ |
| 3.3 | Flujo completo de mesa | 6h | P1 | ✅ |
| **Total Sprint 2** | | **25h** | | **6/6** |

### Sprint 3 (Semanas 5-6): Fiscal + Operación — ✅ COMPLETADO

| ID | Iniciativa | Estimación | Prioridad | Estado |
|----|-----------|------------|-----------|--------|
| 7.1 | CFDI funcional Facturapi | 8h | P0 | ✅ |
| 7.4 | Validación RFC y régimen | 5h | P0 | ✅ |
| 7.2 | Notas de crédito | 6h | P1 | ✅ |
| 3.1 | Impresión ESC/POS | 8h | P1 | ✅ |
| **Total Sprint 3** | | **27h** | | **4/4** |

### Sprint 4 (Semanas 7-8): UX + Analytics — ✅ COMPLETADO

| ID | Iniciativa | Estimación | Prioridad | Estado |
|----|-----------|------------|-----------|--------|
| 5.1 | Mapa visual de mesas | 10h | P1 | ✅ |
| 5.2 | Optimización tablets | 8h | P1 | ✅ |
| 6.1 | Gráficas Chart.js | 8h | P1 | ✅ |
| **Total Sprint 4** | | **26h** | | **3/3** |

### Sprint 5 (Semanas 9-10): Refinamiento + Tests

| ID | Iniciativa | Estimación | Prioridad | Estado |
|----|-----------|------------|-----------|--------|
| 5.3 | Feedback visual | 6h | P1 | ✅ |
| 5.4 | Dashboard admin mejorado | 6h | P1 | ✅ |
| 5.5 | Modo oscuro + accesibilidad | 8h | P2 | ✅ |
| 3.4 | Notas por item mejoradas | 4h | P2 | ✅ |
| **Total Sprint 5** | | **24h** | | **4/4** |

### Sprint 6 (Semanas 11-12): Final + Calidad

| ID | Iniciativa | Estimación | Prioridad | Estado |
|----|-----------|------------|-----------|--------|
| 6.2 | Rentabilidad por producto | 5h | P1 | ✅ |
| 6.3 | Reporte delivery | 4h | P1 | ✅ |
| 6.4 | Export PDF | 8h | P1 | ✅ |
| 7.3 | Complemento de pago | 6h | P2 | ✅ |
| 3.5 | Historial auditoría | 8h | P1 | ✅ |
| 3.6 | Gestión propinas | 4h | P2 | ✅ |
| 2.5 | Test suite pytest | 12h | P1 | ✅ |
| **Total Sprint 6** | | **47h** | | **7/7** |

### Resumen de Esfuerzo

| Sprint | Horas | Semanas |
|--------|-------|---------|
| Sprint 1 | 24h | 1-2 |
| Sprint 2 | 25h | 3-4 |
| Sprint 3 | 27h | 5-6 |
| Sprint 4 | 26h | 7-8 |
| Sprint 5 | 24h | 9-10 |
| Sprint 6 | 47h | 11-12 |
| **Total** | **173h** | **12 semanas** |

---

## 9. Criterios de Aceptación Globales

### Arquitectura y Escalabilidad — 10/10
- [x] PostgreSQL con connection pooling y pool_pre_ping
- [x] Redis activo para sesiones, caché y rate limiting
- [x] Multi-sucursal filtra todos los datos por sucursal activa
- [x] Frontend único (Jinja2), sin deuda técnica React
- [x] Docker multi-stage build < 200MB
- [x] Gunicorn con workers configurables
- [x] Test suite con ≥ 70% cobertura
- [x] Backups automáticos cada hora

### Gestión Operativa — 10/10
- [x] Impresión ESC/POS nativa (comanda + ticket cuenta)
- [x] Validación de stock antes de aceptar pedidos
- [x] Flujo automático de estados de mesa
- [x] Notas por item con sugerencias predefinidas
- [x] Historial de auditoría consultable
- [x] Gestión de propinas con reporteo
- [x] Multi-pago, split, descuentos con autorización
- [x] Timers de cocina con urgencia visual

### Seguridad y Cumplimiento — 10/10
- [x] CSP con nonces, no unsafe-inline ideal
- [x] Webhooks de delivery con verificación de firma
- [x] CORS restrictivo por dominio
- [x] Política de contraseñas enforced
- [x] Anti-enumeración en login
- [x] Protección IDOR en endpoints de mesero
- [x] Sanitización de todos los inputs de texto
- [x] Rate limiting persistente (Redis)
- [x] Security headers completos

### UX/UI — 10/10
- [x] Mapa visual interactivo de mesas
- [x] Optimizado para tablets (touch targets ≥ 48px)
- [x] Feedback visual en cada acción (< 200ms)
- [x] Dashboard admin con 8+ KPIs y gráfica
- [x] Modo oscuro + WCAG 2.1 AA compliance
- [x] PWA instalable con offline support

### Reporteo y Analytics — 10/10
- [x] Gráficas Chart.js en todos los reportes
- [x] Reporte de rentabilidad por producto
- [x] Reporte de delivery por canal
- [x] Export CSV + PDF en todos los reportes
- [x] Dashboard con gráfica de 7 días
- [x] Filtro por rango de fechas universal

### Cumplimiento Fiscal — 10/10
- [x] CFDI timbrado con Facturapi (sandbox probado)
- [x] Notas de crédito (parcial y total)
- [x] Complemento de pago (CFDI "P")
- [x] Validación de RFC con dígito verificador
- [x] Catálogos SAT actualizados (regímenes, usos CFDI)
- [x] IVA 16% automático
- [x] XML y PDF descargables

---

## 10. Riesgos y Mitigaciones

| Riesgo | Impacto | Probabilidad | Mitigación |
|--------|---------|-------------|------------|
| WeasyPrint difícil de instalar en Docker Alpine | Medio | Alta | Usar imagen `python:3.12-slim` (Debian), pre-instalar deps |
| Facturapi sandbox no disponible | Alto | Baja | Mock tests, fallback a modo pendiente |
| ESC/POS varia por modelo de impresora | Medio | Media | Soportar USB y Network genérico, documentar modelos probados |
| CSP rompe funcionalidad existente | Alto | Media | Deploy en Report-Only primero, fix violations, luego enforce |
| Chart.js pesado en conexiones lentas | Bajo | Baja | Lazy load solo en páginas de reportes |
| Test suite toma más tiempo del estimado | Medio | Alta | Priorizar tests de rutas críticas (auth, pagos, inventario) |
| Multi-sucursal rompe queries existentes | Alto | Media | Feature flag `MULTI_SUCURSAL_ENABLED`, tests por módulo |

---

## Migración de Base de Datos (c005)

Todas las iniciativas que requieren cambios de esquema se consolidan en una sola migración:

```
c005_v5_seguridad_auditoria_fiscal.py
```

**Cambios:**
1. `Usuario.debe_cambiar_password` — Boolean, default False
2. `Ingrediente.sucursal_id` — FK nullable a Sucursal
3. `AuditLog` — tabla nueva completa
4. `NotaCredito` — tabla nueva completa
5. `Factura.metodo_pago_cfdi` — String(5), default '01'
6. `Orden.propina` — ya existe, no requiere cambio

---

*Documento generado como guía de ejecución. Cada iniciativa es independiente y puede repriorizarse según necesidades del negocio.*
